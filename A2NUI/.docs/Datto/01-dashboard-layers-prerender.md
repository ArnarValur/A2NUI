# The AI Dashboard × Nuxt Layers × Prerender

> Where A2NUI, Datto, and Nuxt's architectural primitives converge.

---

## 1. The Dashboard from First Principles

Strip the concept to its atoms. The "AI Dashboard" documented in [ai-dashboard-vision.md](file:///media/addinator/Mercury/Libraries/Nuxt/A2NUI/A2NUI/.docs/ai-dashboard-vision.md) makes a bold claim:

> **The agent IS the dashboard.**

What does this mean structurally?

| Traditional Dashboard              | Agent-Owned Dashboard                                 |
| ---------------------------------- | ----------------------------------------------------- |
| Layout hardcoded in Vue templates  | Layout generated by agent via A2UI surfaces           |
| Data fetched by client composables | Data pushed by agent (Datto watches Firestore)        |
| Static widget grid                 | Dynamic surface zones (`kpi`, `ping`, `main`, `chat`) |
| Frontend deploys = UI changes      | Agent decides = UI changes, no redeploy               |

This architecture has a fundamental tension with how traditional web frameworks (including Nuxt) think about pages. Let's examine that tension.

---

## 2. What Nuxt Layers Actually Are

A Nuxt Layer is a self-contained mini-Nuxt application that can provide:

- Components, composables, utils
- Pages, layouts, middleware
- Server routes, plugins
- Its own `nuxt.config.ts` extending the parent

```
extends: ['./layers/base', './layers/dashboard', './layers/a2ui']
```

### The DDD Mapping for DittoDatto

| Layer              | Responsibility                         | Contains                                                    |
| ------------------ | -------------------------------------- | ----------------------------------------------------------- |
| `layers/a2ui-core` | A2UI protocol engine                   | `processor.ts`, `useA2uiSurface.ts`, all `a2ui/` components |
| `layers/dashboard` | Business Portal dashboard shell        | Layout, surface zone routing, ping queue                    |
| `layers/auth`      | Firebase Auth, custom claims, guards   | Composables, middleware                                     |
| `layers/booking`   | Booking flow (hold, confirm, calendar) | Pages, composables, server routes                           |

### Why Layers Matter for the Dashboard

The dashboard is not a "page" — it's a **rendering host** for agent-generated surfaces. By making it a Nuxt Layer:

1. **Isolation**: The A2UI rendering engine (processor, composables, components) lives in `layers/a2ui-core`. It has zero business logic. It doesn't know about bookings, staff, or revenue. It only knows how to turn JSONL into Vue component trees.

2. **Composability**: The `layers/dashboard` layer _extends_ `a2ui-core` and adds the zone layout, ping queue, and portal-specific logic. A different product could extend the same `a2ui-core` layer with a completely different zone layout.

3. **Independent Deployment**: When you update the A2UI processor (e.g., adding a new component type), you update one layer. When you change the dashboard layout, you update a different layer. They version independently.

4. **Testing**: Each layer can be tested in isolation. The `a2ui-core` layer can be tested with synthetic JSONL (as the playground already does). The dashboard layer can be tested with mock surfaces.

---

## 3. Prerender — Where It Applies (and Where It Doesn't)

### The Reality Check

Prerendering generates static HTML at **build time**. The AI Dashboard, by definition, renders content at **runtime** (the agent generates surfaces on-the-fly). These are fundamentally at odds.

**You cannot prerender the dashboard's content.**

But you _can_ prerender the **shell**.

### Hybrid Rendering Strategy

Nuxt's `routeRules` in `nuxt.config.ts` let you specify rendering mode per route:

```ts
// nuxt.config.ts
export default defineNuxtConfig({
  routeRules: {
    // Public marketing pages → prerender for SEO + speed
    "/": { prerender: true },
    "/about": { prerender: true },
    "/pricing": { prerender: true },

    // Dashboard → SPA mode (no SSR needed, auth-gated)
    "/portal/**": { ssr: false },

    // API routes → always server-rendered
    "/api/**": { cors: true },

    // Public store pages → ISR (rebuild every 60s)
    "/stores/**": { isr: 60 },
  },
});
```

### The Three Zones of Rendering

```
┌──────────────────────────────────────────────────────────┐
│                                                          │
│   PRERENDERED (build time)        ISR (cached + refresh) │
│   ┌─────────────┐                 ┌──────────────────┐   │
│   │ Landing     │                 │ /stores/viking   │   │
│   │ /about      │                 │ /stores/salon-x  │   │
│   │ /pricing    │                 │ Refreshes every   │   │
│   │ /blog/*     │                 │ 60 seconds        │   │
│   └─────────────┘                 └──────────────────┘   │
│                                                          │
│   CLIENT-SIDE ONLY (SPA mode, no SSR)                    │
│   ┌───────────────────────────────────────────────────┐  │
│   │  /portal/dashboard  ← Agent-owned, WebSocket      │  │
│   │  /portal/bookings   ← Real-time, auth-gated       │  │
│   │  /portal/staff      ← CRUD, auth-gated            │  │
│   │  /portal/settings   ← User config, auth-gated     │  │
│   └───────────────────────────────────────────────────┘  │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

### What You Gain

| Route Pattern             | Rendering          | Benefit                                                         |
| ------------------------- | ------------------ | --------------------------------------------------------------- |
| `/`, `/about`, `/pricing` | Prerendered        | Instant load, SEO-optimized, zero server cost                   |
| `/stores/{storeId}`       | ISR (60s)          | SEO-visible, always fresh-ish, low server cost                  |
| `/portal/**`              | SPA (`ssr: false`) | No SSR overhead, faster hydration, auth-gated so SEO irrelevant |

### The Dashboard Shell Trick

Even in SPA mode, you can prerender the **dashboard skeleton** — the layout with empty zones. This gives you:

1. Instant visual feedback (sidebar, header, empty KPI placeholders)
2. The A2UI engine boots, connects via WebSocket, and surfaces populate the zones
3. User sees shimmer placeholders → surfaces fade in smoothly

This is the same pattern used by Gmail, Notion, and Figma: ship the shell fast, populate dynamically.

---

## 4. How Layers and Prerender Intersect with Datto

Datto doesn't know about Nuxt. Datto speaks A2A protocol (JSON-RPC 2.0) and generates A2UI JSONL surfaces. The **boundary** between Datto and the Nuxt app is:

```
Datto → [A2UI JSONL over WebSocket] → Nuxt App (A2NUI renderer)
```

The Nuxt app is the **rendering host**. It:

1. Accepts the A2UI stream (via WebSocket composable)
2. Feeds it to the processor (`processor.ts`)
3. Renders the resolved tree via `Renderer.vue` → `Node.vue` → catalog components

Datto never touches Vue, never knows about layers, never cares about SSR. The architecture isolates them completely:

```
┌────────────────────────────────────────────────────┐
│  Nuxt Application                                  │
│                                                    │
│  layers/a2ui-core     ← Protocol engine            │
│  layers/dashboard     ← Zone layout + ping queue   │
│  layers/auth          ← Firebase Auth              │
│  layers/booking       ← Manual booking flow        │
│                                                    │
│  routeRules:                                       │
│    /portal/**  → ssr: false (SPA)                  │
│    /           → prerender: true                   │
│    /stores/**  → isr: 60                           │
│                                                    │
└────────────────┬───────────────────────────────────┘
                 │ WebSocket
                 ▼
┌────────────────────────────────────────────────────┐
│  Datto Agent (MercuryEngine + A2A)                 │
│                                                    │
│  Watches Firestore → generates A2UI surfaces       │
│  Handles A2A tasks → check_availability, etc.      │
│  Pushes visual pings → booking notifications       │
└────────────────────────────────────────────────────┘
```

---

## 5. Key Decisions That Need to Be Made

| Decision                    | Options                         | Recommendation                                                                                                                                             |
| --------------------------- | ------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| When to implement Layers?   | Now vs. later                   | **Later.** The A2NUI app is small. Extract to layers when the Business Portal integration begins. Premature layer extraction adds friction without payoff. |
| Dashboard rendering mode?   | SSR / SPA / Hybrid              | **SPA** (`ssr: false`) for all `/portal/**`. The dashboard is auth-gated, highly dynamic, and SEO-irrelevant. SSR adds complexity with no benefit here.    |
| Prerender what?             | Nothing / Landing / Store pages | **Landing pages + store pages (ISR)**. These are public-facing and benefit from SEO + speed. The dashboard itself is never prerendered.                    |
| Dashboard shell preloading? | Yes / No                        | **Yes.** Ship the layout skeleton immediately. Populate zones asynchronously once the WebSocket connects.                                                  |

---

## 6. Academic Foundation

This architecture maps to established patterns from distributed UI research:

- **Micro-Frontends** (ThoughtWorks, 2016): Nuxt Layers are a first-party, framework-native implementation of the micro-frontend pattern. Each layer is an independently developed, tested, and deployed UI fragment.

- **Server-Driven UI (SDUI)** (Airbnb, 2020; Netflix, 2022): The AI Dashboard is a variant of SDUI where the "server" is an AI agent. The protocol (A2UI) describes the UI declaratively; the client renders it natively.

- **Progressive Hydration** (Google Chrome team, 2019): The dashboard shell trick is progressive hydration in practice — ship the static shell, hydrate the interactive zones incrementally.

- **Island Architecture** (Astro, 2021; adopted by Nuxt 4): Each surface zone in the dashboard is conceptually an "island" — an independently hydrated interactive region within a static shell.

---

_This report establishes that Nuxt Layers provide the right architectural seams for A2NUI, but extraction should be deferred until the Business Portal integration. Prerendering applies to public pages, not the dashboard. The dashboard runs as an SPA with a pre-shipped shell, populated by Datto via WebSocket._
